import { Note, NoteHistory, NoteType, User, Workspace } from '../types';

// --- MOCK DATABASE STATE ---
let users: User[] = [];
let workspaces: Workspace[] = [];
let notes: Note[] = [];

// --- SESSION STATE ---
let sessionUser: User | null = null;

const generateId = () => Math.random().toString(36).substr(2, 9);
const TAGS = ['engineering', 'marketing', 'q4-goals', 'react', 'database', 'policy', 'ideas', 'archive'];

// --- SEEDER ---
export const initializeData = () => {
  if (users.length > 0) return; // Already seeded

  console.log("Seeding Database...");

  // Seed Default User (Demo Account)
  const demoCompanyId = 'c_1';
  const demoUser: User = {
    id: 'u_1',
    name: 'Alex Developer',
    email: 'alex@startup.com',
    avatar: 'https://ui-avatars.com/api/?name=Alex+Developer&background=6366f1&color=fff',
    companyId: demoCompanyId,
    role: 'OWNER',
  };
  users.push(demoUser);

  // Seed Workspaces for Demo User
  for (let i = 0; i < 5; i++) {
    workspaces.push({
      id: `ws_${i}`,
      companyId: demoCompanyId,
      name: i === 0 ? 'Engineering Core' : `Workspace ${generateId()}`,
      description: 'Main workspace for engineering documentation',
      noteCount: Math.floor(Math.random() * 50),
    });
  }

  // Seed Notes
  for (let i = 0; i < 50; i++) {
    const isPublic = Math.random() > 0.3;
    const isDraft = Math.random() > 0.8;
    const noteUser = demoUser;
    
    // Some notes from other companies (public)
    const isExternal = Math.random() > 0.8; 
    const ownerId = isExternal ? 'u_other' : noteUser.id;
    const companyId = isExternal ? 'c_other' : noteUser.companyId;

    notes.push({
      id: `n_${i}`,
      workspaceId: isExternal ? 'ws_other' : workspaces[Math.floor(Math.random() * workspaces.length)].id,
      companyId: companyId,
      title: `Project Note ${i}: ${isDraft ? '(Draft) ' : ''}Update`,
      content: `## Overview\nThis is a sample note content for record #${i}.\n\n* Key point 1\n* Key point 2\n\nGenerated by the seeder system.`,
      tags: [TAGS[Math.floor(Math.random() * TAGS.length)], TAGS[Math.floor(Math.random() * TAGS.length)]],
      type: isPublic ? NoteType.PUBLIC : NoteType.PRIVATE,
      isDraft: isDraft,
      upvotes: Math.floor(Math.random() * 100),
      downvotes: Math.floor(Math.random() * 10),
      createdAt: new Date(Date.now() - Math.random() * 1000000000).toISOString(),
      updatedAt: new Date().toISOString(),
      authorId: ownerId,
      history: [],
    });
  }
  
  // Simulate the background Cron Job for history retention
  runRetentionPolicyCleanup();
};

/**
 * SIMULATED CRON JOB
 * In production, this runs as a separate process/job.
 * Removes history entries older than 7 days.
 */
const runRetentionPolicyCleanup = () => {
    const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
    const now = Date.now();
    let cleanedCount = 0;

    notes.forEach(note => {
        if (note.history && note.history.length > 0) {
            const originalLen = note.history.length;
            note.history = note.history.filter(h => {
                const hDate = new Date(h.timestamp).getTime();
                return (now - hDate) < SEVEN_DAYS_MS;
            });
            cleanedCount += (originalLen - note.history.length);
        }
    });
    
    if (cleanedCount > 0) {
        console.log(`[System Cron] Retention Policy Executed. Cleaned ${cleanedCount} old history entries.`);
    }
};

// --- AUTHENTICATION SERVICE ---

export const login = async (email: string, password: string): Promise<User> => {
    await delay(600);
    // Simple mock auth - in real app, check password hash
    const user = users.find(u => u.email.toLowerCase() === email.toLowerCase());
    
    // For demo purposes, we accept any password if user exists, 
    // OR if user doesn't exist, we fail (unless it's the demo account check)
    if (!user) {
        throw new Error("Invalid credentials");
    }
    
    sessionUser = user;
    return user;
};

export const register = async (name: string, email: string, password: string, companyName: string): Promise<User> => {
    await delay(800);
    if (users.find(u => u.email === email)) {
        throw new Error("Email already registered");
    }

    const newCompanyId = `c_${generateId()}`;
    const newUser: User = {
        id: `u_${generateId()}`,
        name,
        email,
        avatar: `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&background=random`,
        companyId: newCompanyId,
        role: 'OWNER'
    };

    users.push(newUser);
    
    // Create Default Workspace
    workspaces.push({
        id: `ws_${generateId()}`,
        companyId: newCompanyId,
        name: 'General',
        description: `Main workspace for ${companyName}`,
        noteCount: 0
    });

    sessionUser = newUser;
    return newUser;
};

export const logout = async () => {
    sessionUser = null;
};

export const getCurrentUser = () => sessionUser;


// --- DATA ACCESS LAYER (DAL) ---

export const getWorkspaces = async (): Promise<Workspace[]> => {
  await delay(300); 
  if (!sessionUser) throw new Error("Unauthorized");
  return workspaces.filter(w => w.companyId === sessionUser!.companyId);
};

export const createWorkspace = async (name: string): Promise<Workspace> => {
  await delay(500);
  if (!sessionUser) throw new Error("Unauthorized");
  
  const newWorkspace: Workspace = {
    id: `ws_${generateId()}`,
    companyId: sessionUser.companyId,
    name: name,
    description: 'Created via dashboard',
    noteCount: 0,
  };
  workspaces.unshift(newWorkspace);
  return newWorkspace;
};

export const getPublicNotes = async (
  query: string,
  sort: string
): Promise<Note[]> => {
  await delay(400); 
  // Public notes from ALL companies
  let results = notes.filter(n => n.type === NoteType.PUBLIC && !n.isDraft);

  if (query) {
    const lowerQ = query.toLowerCase();
    results = results.filter(n => n.title.toLowerCase().includes(lowerQ));
  }

  return results.sort((a, b) => {
    switch (sort) {
      case 'newest': return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
      case 'oldest': return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime();
      case 'popular': // Most Upvotes
        return b.upvotes - a.upvotes;
      case 'downvotes': // Most Downvotes
        return b.downvotes - a.downvotes;
      case 'controversial': 
        return (b.upvotes + b.downvotes) - (a.upvotes + a.downvotes);
      default: return 0;
    }
  });
};

export const getWorkspaceNotes = async (workspaceId: string, query: string): Promise<Note[]> => {
  await delay(300);
  if (!sessionUser) throw new Error("Unauthorized");

  // Security check: Ensure workspace belongs to user's company
  const ws = workspaces.find(w => w.id === workspaceId);
  if (!ws || ws.companyId !== sessionUser.companyId) {
      return []; // Or throw error
  }

  let results = notes.filter(n => n.workspaceId === workspaceId);
  if (query) {
    results = results.filter(n => n.title.toLowerCase().includes(query.toLowerCase()));
  }
  return results.sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());
};

export const getNoteById = async (id: string): Promise<Note | undefined> => {
  await delay(200);
  // In a real app, we would check permissions here (is it public? or does it belong to my company?)
  const note = notes.find(n => n.id === id);
  if (!note) return undefined;

  // Simple ACL
  if (note.type === NoteType.PRIVATE) {
      if (!sessionUser || note.companyId !== sessionUser.companyId) return undefined;
  }
  
  return note;
};

export const saveNote = async (note: Partial<Note> & { id?: string, workspaceId: string }): Promise<Note> => {
  await delay(500);
  if (!sessionUser) throw new Error("Unauthorized");
  
  if (note.id) {
    // UPDATE
    const index = notes.findIndex(n => n.id === note.id);
    if (index === -1) throw new Error("Note not found");

    const existing = notes[index];
    
    // Permission check
    if (existing.companyId !== sessionUser.companyId) throw new Error("Forbidden");
    
    if (note.content && note.content !== existing.content) {
      const historyEntry: NoteHistory = {
        id: generateId(),
        noteId: existing.id,
        content: existing.content,
        updatedBy: sessionUser.id,
        timestamp: new Date().toISOString()
      };
      existing.history.unshift(historyEntry); 
    }

    const updatedNote = {
      ...existing,
      ...note,
      updatedAt: new Date().toISOString(),
      updatedBy: sessionUser.id
    };
    
    notes[index] = updatedNote;
    return updatedNote;
  } else {
    // CREATE
    const newNote: Note = {
      id: generateId(),
      workspaceId: note.workspaceId,
      companyId: sessionUser.companyId,
      title: note.title || 'Untitled Note',
      content: note.content || '',
      tags: note.tags || [],
      type: note.type || NoteType.PRIVATE,
      isDraft: note.isDraft ?? true,
      upvotes: 0,
      downvotes: 0,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      authorId: sessionUser.id,
      history: []
    };
    notes.push(newNote);
    
    const ws = workspaces.find(w => w.id === note.workspaceId);
    if (ws) ws.noteCount++;
    
    return newNote;
  }
};

export const deleteNote = async (id: string) => {
    await delay(300);
    if (!sessionUser) throw new Error("Unauthorized");
    
    const index = notes.findIndex(n => n.id === id);
    if (index === -1) throw new Error("Note not found");
    
    const note = notes[index];
    if (note.companyId !== sessionUser.companyId) throw new Error("Forbidden");
    
    notes.splice(index, 1);
    
    const ws = workspaces.find(w => w.id === note.workspaceId);
    if (ws && ws.noteCount > 0) ws.noteCount--;
};

export const voteNote = async (id: string, type: 'up' | 'down') => {
  const note = notes.find(n => n.id === id);
  if (note) {
    if (type === 'up') note.upvotes++;
    else note.downvotes++;
  }
};

export const restoreNoteHistory = async (noteId: string, historyId: string): Promise<Note> => {
    if (!sessionUser) throw new Error("Unauthorized");
    const note = notes.find(n => n.id === noteId);
    if (!note) throw new Error("Note not found");
    if (note.companyId !== sessionUser.companyId) throw new Error("Forbidden");

    const historyEntry = note.history.find(h => h.id === historyId);
    if (!historyEntry) throw new Error("Version not found");

    note.history.unshift({
        id: generateId(),
        noteId: note.id,
        content: note.content,
        updatedBy: sessionUser.id,
        timestamp: new Date().toISOString()
    });

    note.content = historyEntry.content;
    note.updatedAt = new Date().toISOString();
    return { ...note };
}

const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

initializeData();